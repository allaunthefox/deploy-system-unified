---
# Tasks for networking/physical

- name: Install networking tools
  ansible.builtin.package:
    name:
      - ethtool
      - lshw
      - irqbalance # Essential for multi-queue NICs (Bare Metal), skipped for VMs
    state: present
  when: networking_physical_install_tools
  become: true

- name: Disable IRQBalance in Virtualized Environments
  ansible.builtin.systemd:
    name: irqbalance
    state: stopped
    enabled: false
  when:
    - is_virtualized
    - networking_physical_install_tools
  become: true
  ignore_errors: true

- name: Detect physical interfaces
  ansible.builtin.set_fact:
    physical_interfaces: >-
      {{
        ansible_interfaces
        | map('regex_replace', '^', 'ansible_')
        | map('extract', ansible_facts)
        | select('defined')
        | selectattr('type', 'defined')
        | selectattr('type', 'equalto', 'ether')
        | map(attribute='device')
        | list
      }}

- name: Gather ethtool facts for physical interfaces
  ansible.builtin.command: "ethtool {{ item }}"
  register: ethtool_output
  changed_when: false
  failed_when: false
  loop: "{{ physical_interfaces }}"
  become: true

- name: Parse Interface Types and Capabilities
  vars:
    # Standardize all speeds to Megabits per second (Mbps)
    # Supports SI (decimal) and IEC (binary) prefixes, as well as Byte-based units
    # Scales from Nibble (insane) to Exabit (future-proof)
    _speed_conversion_map:
      'b': 0.000001     # Bits
      'B': 0.000008     # Bytes (x8)
      'nb': 0.000004    # Nibbles (x4) - The "Insane Admin" Special
      'Kb': 0.001       # Kilobits
      'KB': 0.008       # Kilobytes (x8)
      'Kib': 0.001024   # Kibibits
      'KiB': 0.008192   # Kibibytes
      'Mb': 1.0         # Megabits (Base)
      'MB': 8.0         # Megabytes (x8)
      'Mib': 1.048576   # Mebibits
      'MiB': 8.388608   # Mebibytes
      'Gb': 1000.0      # Gigabits
      'GB': 8000.0      # Gigabytes (x8)
      'Gib': 1073.742   # Gibibits
      'GiB': 8589.935   # Gibibytes
      'Tb': 1000000.0   # Terabits
      'TB': 8000000.0   # Terabytes (x8)
      'Tib': 1099511.6  # Tebibits
      'TiB': 8796093.0  # Tebibytes
      'Pb': 1000000000.0      # Petabits
      'PB': 8000000000.0      # Petabytes (x8)
      'Pib': 1125899906.84    # Pebibits
      'PiB': 9007199254.74    # Pebibytes
      'Eb': 1000000000000.0   # Exabits
      'EB': 8000000000000.0   # Exabytes (x8)
      'Eib': 1152921504606.85 # Exbibits
      'EiB': 9223372036854.78 # Exbibytes
  ansible.builtin.set_fact:
    interface_capabilities: "{{ interface_capabilities | default({}) | combine({ item.item: {
      'port_type': (item.stdout | regex_search('Port: ([a-zA-Z]+)', '\\1') | first | default('Unknown') | trim),
      'link_detected': (item.stdout | regex_search('Link detected: ([a-zA-Z]+)', '\\1') | first | default('no') | trim),
      'speed_mbps': ((item.stdout | regex_search('Speed: ([0-9]+)', '\\1') | first | default('0') | int) * (_speed_conversion_map.get((item.stdout | regex_search('Speed: [0-9]+\s*([a-zA-Z]+)/s', '\\1') | first | default('Mb')), 1.0))) | int
    }}) }}"
  loop: "{{ ethtool_output.results }}"
  when: item.rc == 0

- name: Debug Interface Capabilities
  ansible.builtin.debug:
    var: interface_capabilities
    verbosity: 1

# --- System-Wide Kernel Tuning (Based on Fastest Interface) ---

- name: Determine Max Interface Speed
  ansible.builtin.set_fact:
    max_interface_speed: "{{ interface_capabilities.values() | map(attribute='speed_mbps') | map('int') | max | default(1000) }}"

- name: Select Performance Profile
  ansible.builtin.set_fact:
    active_profile: "{{ networking_physical_profiles[max_interface_speed|string] | default(networking_physical_profiles[networking_physical_default_profile]) }}"

- name: Apply High-Speed Kernel Tuning (Sysctl)
  ansible.posix.sysctl:
    name: "{{ item.name }}"
    value: "{{ item.value }}"
    state: present
    sysctl_file: /etc/sysctl.d/98-networking-performance.conf
    reload: "{{ ansible_virtualization_type not in ['docker', 'podman', 'container'] }}"
  ignore_errors: "{{ ansible_virtualization_type in ['docker', 'podman', 'container'] }}"
  loop:
    - { name: 'net.core.rmem_max', value: "{{ active_profile.rmem_max }}" }
    - { name: 'net.core.wmem_max', value: "{{ active_profile.wmem_max }}" }
    - { name: 'net.core.netdev_max_backlog', value: "{{ active_profile.netdev_backlog }}" }
    - { name: 'net.ipv4.tcp_rmem', value: "{{ active_profile.tcp_rmem }}" }
    - { name: 'net.ipv4.tcp_wmem', value: "{{ active_profile.tcp_wmem }}" }
  become: true
  when: networking_physical_ring_tuning_enabled

# --- Per-Interface Tuning (Jumbo Frames & Ring Buffers) ---

- name: Apply Jumbo Frames to High Speed/Fiber Interfaces
  ansible.builtin.command: "ip link set dev {{ item.key }} mtu {{ networking_physical_jumbo_mtu }}"
  loop: "{{ interface_capabilities | dict2items }}"
  when:
    - networking_physical_manage_mtu
    - networking_physical_jumbo_frames_enabled
    - item.value.link_detected == 'yes'
    - (item.value.speed | int) >= 10000 or item.value.port_type in ['FIBRE', 'Direct Attach Copper', 'DA']
  become: true
  notify: restart networkmanager

- name: Tune Ring Buffers (Adaptive per Interface Speed)
  ansible.builtin.command: >-
    ethtool -G {{ item.key }}
    rx {{ (networking_physical_profiles[item.value.speed_mbps|string] | default(networking_physical_profiles[networking_physical_default_profile])).ring_rx }}
    tx {{ (networking_physical_profiles[item.value.speed_mbps|string] | default(networking_physical_profiles[networking_physical_default_profile])).ring_tx }}
  loop: "{{ interface_capabilities | dict2items }}"
  when:
    - networking_physical_ring_tuning_enabled
    - item.value.link_detected == 'yes'
    # Skip Ring Tuning on Virtual Interfaces (VirtIO/VmxNet3 often has fixed rings)
    - not is_virtualized
  become: true
  ignore_errors: true # Hardware might not support specific ring sizes

- name: Apply Offload Settings (TSO/GSO)
  ansible.builtin.command: >
    ethtool -K {{ item.key }}
    tso {{ 'on' if networking_physical_enable_tso else 'off' }}
    gso {{ 'on' if networking_physical_enable_gso else 'off' }}
  loop: "{{ interface_capabilities | dict2items }}"
  when:
    - networking_physical_offload_tuning_enabled
    - item.value.link_detected == 'yes'
  become: true
