---
- ansible.builtin.import_playbook: bootstrap_ssh.yml

- name: Preflight - Verify backup integrity before restore
  hosts: localhost
  gather_facts: false
  tasks:
    - name: Check for hash verification tools
      ansible.builtin.command: which sha256sum sha512sum openssl
      register: hash_tools_check
      changed_when: false
      failed_when: false

    - name: Fail if hash tools missing
      ansible.builtin.fail:
        msg: "Hash verification tools required for restore"
      when: hash_tools_check.rc != 0

    - name: Check for hash manifest
      ansible.builtin.stat:
        path: "/var/backups/security/hash_manifest.txt"
      register: hash_manifest_check

    - name: Fail if no hash manifest found during restore
      ansible.builtin.fail:
        msg: "CRITICAL: No hash manifest found. Cannot verify backup integrity. Restore aborted for security."
      when: not hash_manifest_check.stat.exists

- name: Restore Migration Data
  hosts: all
  become: true
  vars:
    migration_source: "{{ playbook_dir }}/../migration_assets"
    # Destination Paths (Must match role defaults)
    containers_media_config_dir: "/srv/containers/media_config/default"
    ops_config_dir: "/srv/containers/ops_config"
    containers_media_puid: 1000
    containers_media_pgid: 1000

  tasks:
    # -------------------------------------------------------
    # 1. FILE-BASED RESTORATIONS (SQLite & Configs)
    # -------------------------------------------------------

    # Jellyfin
    - name: Ensure Jellyfin config dir exists
      ansible.builtin.file:
        path: "{{ containers_media_config_dir }}/jellyfin/data"
        state: directory
        recurse: true
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"

    - name: Restore Jellyfin DB
      ansible.builtin.copy:
        src: "{{ migration_source }}/databases/jellyfin.db"
        dest: "{{ containers_media_config_dir }}/jellyfin/data/jellyfin.db"
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"
        mode: '0644'

    # Radarr (Root config dir usually contains radarr.db)
    - name: Restore Radarr DB
      ansible.builtin.copy:
        src: "{{ migration_source }}/databases/radarr.db"
        dest: "{{ containers_media_config_dir }}/radarr/radarr.db"
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"
        mode: '0644'

    # Sonarr
    - name: Restore Sonarr DB
      ansible.builtin.copy:
        src: "{{ migration_source }}/databases/sonarr.db"
        dest: "{{ containers_media_config_dir }}/sonarr/sonarr.db"
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"
        mode: '0644'

    # Vaultwarden (Volume Archive)
    - name: Ensure Vaultwarden dir
      ansible.builtin.file:
        path: "{{ ops_config_dir }}/vaultwarden"
        state: directory
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"

    - name: Restore Vaultwarden Data
      ansible.builtin.unarchive:
        src: "{{ migration_source }}/databases/volumes/vaultwarden.tar"
        dest: "{{ ops_config_dir }}/vaultwarden"
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"
        # "strip_components" depends on how it was tarred.
        # Inspecting lists showed "databases/volumes/vaultwarden.tar", contents inside usually start with "data/" or "."
        # Safest is to extract and then move if needed, or assume standard structure.
        extra_opts:
          - --strip-components=0
          # Warning: Check inside the tar first!

    # Homarr
    - name: Restore Homarr Data
      ansible.builtin.unarchive:
        src: "{{ migration_source }}/databases/volumes/homarr.tar"
        dest: "{{ ops_config_dir }}/homarr"
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"

    # Wastebin
    - name: Restore Wastebin Data
      ansible.builtin.unarchive:
        src: "{{ migration_source }}/databases/volumes/wastebin.tar"
        dest: "{{ ops_config_dir }}/wastebin"
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"

    # -------------------------------------------------------
    # 2. POSTGRESQL RESTORATIONS (Authentik & Wiki.js)
    # -------------------------------------------------------
    # Requires containers to be running.

    - name: Copy Authentik SQL to Host Tmp
      ansible.builtin.copy:
        src: "{{ migration_source }}/databases/postgres/authentik.sql"
        dest: "/tmp/authentik.sql"

    - name: Wait for Authentik DB
      ansible.builtin.command: podman exec -i authentik-db-default pg_isready -U postgres
      register: db_check
      retries: 30
      delay: 2
      until: db_check.rc == 0
      failed_when: false

    - name: Drop & Create Authentik DB (Fresh Install State)
      ansible.builtin.command: |
        podman exec -i authentik-db-default psql -U postgres -c "DROP DATABASE IF EXISTS authentik; CREATE DATABASE authentik;"
      when: db_check.rc == 0

    - name: Import Authentik Dump
      ansible.builtin.shell: |
        podman exec -i authentik-db-default psql -U postgres -d authentik < /tmp/authentik.sql
      when: db_check.rc == 0
      register: import_result

    - name: Debug Import
      ansible.builtin.debug:
        var: import_result

    # -------------------------------------------------------
    # 3. PERMISSIONS FIX
    # -------------------------------------------------------
    - name: Fix Recursive Permissions
      ansible.builtin.file:
        path: "{{ item }}"
        owner: "{{ containers_media_puid }}"
        group: "{{ containers_media_pgid }}"
        recurse: true
      loop:
        - "{{ containers_media_config_dir }}"
        - "{{ ops_config_dir }}"
