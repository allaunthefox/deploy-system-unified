---
# Tasks for hardware/storage_tuning - Physical Storage Optimization
- name: Enable SSD TRIM timer (FSTRIM)
  ansible.builtin.systemd:
    name: fstrim.timer
    enabled: true
    state: started
  become: true
  failed_when: false
- name: Set I/O scheduler for disks (Physical, Virtual, Flash, RAM)
  ansible.builtin.copy:
    content: |
      # Physical Flash (SSD/NVMe/SD/eMMC/USB-Flash) - Low Latency
      ACTION=="add|change", KERNEL=="sd[a-z]*|nvme[0-9]*|mmcblk[0-9]*", ATTR{queue/rotational}=="0", ATTR{queue/scheduler}="mq-deadline"

      # Virtual Disks (VirtIO/Xen) - Delegate to Host
      ACTION=="add|change", KERNEL=="vd[a-z]*|xvd[a-z]*", ATTR{queue/scheduler}="none mq-deadline"

      # RAM Disks (zram/brd) - Zero Latency, No Scheduling
      ACTION=="add|change", KERNEL=="ram[0-9]*|zram[0-9]*", ATTR{queue/scheduler}="none"
    dest: /etc/udev/rules.d/60-disk-scheduler.rules
    mode: '0644'
  become: true
  notify: reload_udev

- name: Gather storage device facts (Robust & Aligned)
  ansible.builtin.command: lsblk -d -o NAME,SIZE,ROTA,PHY-SEC,OPT-IO -n --bytes
  register: lsblk_output
  changed_when: false
  become: true

- name: Normalize Storage Device Capacities & Alignment
  vars:
    # Standardize all storage to Megabytes (MB)
    # Robustly handles bits (insane), bytes, and IEC/SI prefixes up to Exabytes
    _storage_conversion_map:
      'b': 0.000000125  # Bits (1/8 Byte)
      'B': 0.000001     # Bytes
      'nb': 0.0000005   # Nibbles (1/2 Byte) - Resilience test
      'KB': 0.001       # Kilobytes (10^3)
      'KiB': 0.001024   # Kibibytes (2^10)
      'MB': 1.0         # Megabytes (Base)
      'MiB': 1.048576   # Mebibytes
      'GB': 1000.0      # Gigabytes
      'GiB': 1073.742   # Gibibytes
      'TB': 1000000.0   # Terabytes
      'TiB': 1099511.6  # Tebibytes
      'PB': 1000000000.0     # Petabytes
      'PiB': 1125899906.84   # Pebibytes
      'EB': 1000000000000.0  # Exabytes
      'EiB': 1152921504606.85 # Exbibytes
  ansible.builtin.set_fact:
    storage_devices_norm: "{{ storage_devices_norm | default({}) | combine({
      (item.split()[0]): {
        'rotational': (item.split()[2] | bool),
        'phy_sec_bytes': (item.split()[3] | int),
        'opt_io_bytes': (item.split()[4] | int),
        'size_mb': ((item.split()[1] | regex_search('([0-9.]+)', '\\1') | default('0') | float) * (_storage_conversion_map.get((item.split()[1] | regex_search('([a-zA-Z]+)', '\\1') | default('B')), 1.0))) | int
      }
    }) }}"
  loop: "{{ lsblk_output.stdout_lines }}"

- name: Apply Aligned Read-Ahead Tuning (>1TB)
  vars:
    # Default Read-Ahead: 2MB (4096 sectors * 512b)
    # Alignment fallback: Ensure multiple of Physical Sector
    default_ra_sectors: 4096
  ansible.builtin.command: >-
    blockdev --setra
    {{
       ((item.value.opt_io_bytes | int > 0) | ternary(
          ((item.value.opt_io_bytes | int) / 512) | int,
          default_ra_sectors
       )) | int
    }}
    /dev/{{ item.key }}
  loop: "{{ storage_devices_norm | dict2items }}"
  when:
    - item.value.size_mb > 1000000 # > 1TB
    # Support Physical (sd/nvme/mmc), Virtual (vd/xvd), and External (USB/SD)
    - item.key is match("sd[a-z]+|nvme[0-n]+n[0-9]+|vd[a-z]+|xvd[a-z]+|mmcblk[0-9]+")
    # Skip RAM disks (zram/ram) as they don't benefit from readahead
    - not (item.key is match("zram[0-9]+|ram[0-9]+"))
    # Boundary Guard: Ensure readahead is at least 4k aligned (8 sectors)
    - item.value.phy_sec_bytes | int >= 4096 or item.value.phy_sec_bytes | int == 512
  become: true
  changed_when: false
  failed_when: false